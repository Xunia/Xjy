<!-- TOC -->

- [**关于java语言设计理念**](#关于java语言设计理念)
    - [运算符](#运算符)
        - [算术运算符](#算术运算符)
        - [位运算符](#位运算符)
    - [**关键字**](#关键字)
        - [常用关键字](#常用关键字)
        - [**抽象类与接口的区别是什么**](#抽象类与接口的区别是什么)

<!-- /TOC -->

# **关于java语言设计理念**
面向对象编程语言


## 运算符
### 算术运算符
|操作符  | 	描述  |	例子|
|:----:|:----|:----|
|+|	    加法 - 相加运算符两侧的值	      | A + B 等于 30
|-|	    减法 - 左操作数减去右操作数	      | A – B 等于 -10
|*|	    乘法 - 相乘操作符两侧的值	      | A * B等于200
|/|	    除法 - 左操作数除以右操作数	      | B / A等于2
|%|	    取余 - 左操作数除以右操作数的余数 |	B%A等于0
|++|	自增: 操作数的值增加1            |	B++ 或 ++B 等于 21（区别：当前输出printf（{0}）
|--|	自减: 操作数的值减少1            |	B-- 或 --B 等于 19

### 位运算符
A = 0011 1100
B = 0000 1101
-----------------
A&b   = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A    = 1100 0011

|操作符 |	描述    |	例子|
|:----:|:----|:----|
|<<  |	按位左移运算符。左操作数按位左移右操作数指定的位数。| A << 2得到240，即 1111 0000
|>>  |	按位右移运算符。左操作数按位右移右操作数指定的位数。| A >> 2得到15即 1111
|>>> |	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。|	A>>>2得到15即0000 1111



## **关键字**


### 常用关键字






### **抽象类与接口的区别是什么**
|参数	|抽象类	 |接口|
|:----:|:----|:----|
|默认的方法实现 |	它可以有默认的方法实现 |	接口完全是抽象的。它根本不存在方法的实现|
|实现|	子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。|	子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现|
|构造器|	抽象类可以有构造器 |	接口不能有构造器|
|与正常Java类的区别|	除了你不能实例化抽象类之外，它和普通Java类没有任何区别 |	接口是完全不同的类型|
|访问修饰符|	抽象方法可以有public、protected和default这些修饰符 |	接口方法默认修饰符是public。你不可以使用其它修饰符。|
|main方法|	抽象方法可以有main方法并且我们可以运行它  |	接口没有main方法，因此我们不能运行它。（java8以后接口可以有**default**和**static**方法，所以可以运行main方法）|
|多继承|	抽象方法可以继承一个类和实现多个接口  |	接口只可以继承一个或多个其它接口 |
|速度|	它比接口速度要快 |	接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。|
|添加新方法|	如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。|	如果你往接口中添加方法，那么你必须改变实现该接口的类。|


接口（interface）的定义：接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。
抽象类（abstract ）的定义: 抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。


**问题**：什么时候用接口什么时候用抽象类？

如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。
什么时候使用抽象类？

抽象类让你可以定义一些默认行为并促使子类提供任意特殊化行为。


**枚举**

java里的枚举实现机制是什么
枚举类型在编译器处理之后，是由一个final的继承Enum类的类实现的。该类是一个实实在在存在的类。在该类当中，编译器还帮助我们生成了每个枚举类型的实例对象，这些对象分别对应枚举中定义的每个枚举类型本身。

**内部类**

java中的内部类
定义：将一个类的定义放在另一个类的定义内部，即为内部类。

内部类本质上是java的一种"语法糖"。为什么这样说呢？举例说明，假设现在有如下代码：

```
public class A {
    private int a;
    static class B {
 
    }
 
    class C {
        public void test(){
            int b  = a;
        }
    }
}
```
类A是一个普通的类，在他的内部定义了两个类B，以及C。从代码结构上来看，B类和C类为A类的内部，但是在使用编译器编译之后，它们并不是一个类，而是会变成符合一定名称规则的三个类，如下图所示：



它在编译之后会产生三个.class文件，分别是：A.class, A$B.class, A$C.class. 因此，本质上它们还是三个类，只是借助于java编译器的语法糖支持，我们可以写在一个类里面，从这个例子我们不难推断出，在java 里任何一个类，无论是以怎样的形式定义，在编译之后生成字节码文件之后，其必然是一个单独存在的类。理解java的类加载机制的话对这句话理解起来就更加容易，java加载任何一个类的时候都是会首先从加载其class文件开始，若一个类不存在对应的class文件，那么它必然无法被加载也无法被使用。

同时，知道了上述知识之后，我们来看这样两个问题：

内部类可以被继承吗？答案是肯定可以的，只是从java语法来说写起来会稍微有点区别
内部类的方法可以被覆盖吗？答案一样是可以的。
为何java编译器会支持定义内部类这样的使用方式，原因在于当一个类定义在另一个类内部之后，许多操作会变得简单一些，比如一个内部类可以直接访问外部类的任何成员。为什么内部类能直接访问外部类的任何成员呢？原因在于java编译器对内部类的功能t提供了支持，让我们再来看上述代码反编译回来的结果：

public class A {
    private int a;
 
    public A() {
    }
 
    class C {
        C() {
        }
 
        public void test() {
            int b = A.this.a;//通过类名加this关键字
        }
    }
 
    static class B {
        B() {
        }
    }
}
可以看到是通过类名跟上.this关键字实现的对外部成员的访问，这相当于是隐式的持有了一个外部类引用，即建立了一个内部类和外部类之间的联系。

同时，这里我们需要注意这里的B类声明成了static的类，C类则没有。我们常常把用static修饰的内部类成为嵌套类。

他们的区别在于，嵌套类与外围类之间是没有联系的。这意味这创建嵌套类无需外部类，当然，也不能从嵌套类的对象中访问非静态的外围类对象。同时，在嵌套类的内部可以使用static关键字，而普通的内部类不能使用static关键字。

用途：从代码的组织结构来说，使用内部类可以把逻辑相关的类组织在一起。内部类访问外部类将非常方便，内部类能访问外围对象的所有成员，且不需要任何特殊条件。但这不是最主要的原因，从设计角度出发，使用内部类最大的原因在于：每个内部类可以独立但继承一个类，这意味着虽然java的类是单继承的，但是通过使用内部类，可以达到类似多重继承的效果。因此，如果不需要解决多重继承的问题，使用内部类就并不是必须的了，因为其他的编码方式都能实现一样的效果。

关于其他语法糖的介绍可以参考博客:java中的语法糖

关于类Collections,Arrays,Objects
在jdk源代码中提供了很多有用的工具类，它们的命名也有一定的规律。

Collections类提供了很多给容器使用的实用方法。

Arrays类提供了很多给给数组容器有用的方法。例如想创建一个数组对象可以直接调用方法Arrays.asList(...)

Objects类提供了一些给Object类中的实用方法.

这些类都位于jdk的java.util包下面。除了上面提到的三个类以外，util包下面还有许多非常有用且也经常被用到的类和包，例如正则表达式相关的类，基本类型转换的类，以及流编程的类等等，感兴趣的读者可以自行查看。

java里的方法重载
所谓方法重载，指的是当两个方法具有相同的方法名称的时候，他们共存的一种方式。下面是两个重载方法的例子:

public class TestOverloading {
    public void method(String s){
 
    }
    public void method(int  i){
 
    }
}
对于方法名称相同的：

参数数量一样，类型不一样，可以重载
参数数量不一样可以重载
参数数量一样，相同位置类型不一样，可以重载
对于第三种情况,实例代码如下：

public class TestOverloading {
    public void method(String s, int i){
 
    }
    public void method(int  i, String s){
 
    }
}
注意，方法返回值不作为方法标识之一，下列方法是不能重载的

public class TestOverloading {
    public int method(  int i){
        return 1;
    }
    public String method(int  i){
        return "2";
    }
}
关于java里的main方法
所有的java程序无论大小，只要能运行必定有一个main方法，关于java的main方法的分析请参考博客：[java] 关于main方法的一切。

JVM,JDK,JRE三者的关系是什么
JVM指的是java virtual machine, 即java虚拟机。

是运行java代码的引擎。在其他主要的编程语言中，代码的编译器都只会为某个特定系统生成编译之后的代码，也就是说这部分代码只能在特定的系统上执行。而java编译器不为特定的平台生成字节码，而是为Java虚拟机生成字节码，编译生成的字节码是可用于在任何平台上运行的源代码，因此jvm成为了将Java代码编译为字节码的媒介，它在不同的机器上进行解释，使的java语言与平台/操作系统独立。字节码相当于是Java源代码和主机系统之间的中介语言。

一个java虚拟机主要做了下面几件事：

阅读字节码。
验证字节码。
将代码与库链接。
可以用下图解释jvm主要做的事情


